# How Alarms Are Mocked - Complete Flow

## Overview
This document explains how alarms are generated by the Mock PLC Agent and how they flow through the system to appear in the frontend.

---

## Step-by-Step Flow

### 1. **Mock PLC Agent Generates Alarms** (`mock_plc_agent/mock_plc_agent.py`)

**Location:** Lines 105-111

**What happens:**
- Every 2 seconds (PUBLISH_INTERVAL), the agent calls `generate_mock_data()`
- Alarms are generated with random probabilities:

```python
"alarms": {
    "LowProductLevel": random.random() > 0.94,  # 6% chance
    "Overfill": random.random() > 0.96,         # 4% chance
    "Underfill": random.random() > 0.95,         # 5% chance
    "NoBottle": not self.filling,                # True when not filling
    "CapMissing": random.random() > 0.93 if self.filling else False,  # 7% chance when filling
}
```

**Current Probabilities:**
- **LowProductLevel**: 6% chance per cycle
- **Overfill**: 4% chance per cycle
- **Underfill**: 5% chance per cycle
- **NoBottle**: Depends on filling state
- **CapMissing**: 7% chance when filling

### 2. **Agent Publishes to MQTT** (`mock_plc_agent/mock_plc_agent.py`)

**Location:** Lines 230-253

**What happens:**
- Agent publishes alarms to MQTT topic: `plc/{MACHINE_ID}/bottlefiller/alarms`
- Example topic: `plc/machine-01/bottlefiller/alarms`
- Payload is a JSON object with alarm states:

```json
{
  "LowProductLevel": true,
  "Overfill": false,
  "Underfill": false,
  "NoBottle": false,
  "CapMissing": true
}
```

**Code:**
```python
client.publish(f"plc/{MACHINE_ID}/bottlefiller/alarms", json.dumps(data["alarms"]), qos=1)
```

### 3. **Alarm Monitor Subscribes to MQTT** (`alarm_monitor/alarm_monitor.py`)

**Location:** Lines 169-178

**What happens:**
- Alarm Monitor connects to MQTT broker
- Subscribes to topics:
  - `plc/+/bottlefiller/alarms` (wildcard for all bottle filler machines)
  - `plc/+/lathe/alarms` (wildcard for all lathe machines)

**Code:**
```python
client.subscribe(MQTT_TOPIC_BOTTLEFILLER)  # "plc/+/bottlefiller/alarms"
client.subscribe(MQTT_TOPIC_LATHE)          # "plc/+/lathe/alarms"
```

### 4. **Alarm Monitor Receives MQTT Messages** (`alarm_monitor/alarm_monitor.py`)

**Location:** Lines 179-234

**What happens:**
- `on_message()` callback receives alarm data from MQTT
- Extracts `machine_id` from topic: `plc/{machine_id}/bottlefiller/alarms`
- Determines machine type (bottlefiller or lathe)
- Parses alarm payload (JSON object with alarm states)

### 5. **Alarm Monitor Detects State Transitions** (`alarm_monitor/alarm_monitor.py`)

**Location:** Lines 85-167 (`check_alarm_transitions()`)

**What happens:**
- Compares current alarm state with previous state
- Tracks previous states per machine in `previous_alarms` dictionary
- Detects two types of transitions:

**A. Alarm RAISED** (false → true):
```python
if not prev_value and current_value:
    # Alarm just turned ON
    state = "RAISED"
```

**B. Alarm CLEARED** (true → false):
```python
elif prev_value and not current_value:
    # Alarm just turned OFF
    state = "CLEARED"
```

**Important:** Only state transitions trigger events, not continuous states!

### 6. **Alarm Monitor Broadcasts via WebSocket** (`alarm_monitor/alarm_monitor.py`)

**Location:** Lines 68-83, 127-136, 153-162

**What happens:**
- When a transition is detected, creates a WebSocket message:

```json
{
  "machine_id": "machine-01",
  "alarm_name": "LowProductLevel",
  "alarm_type": "AlarmLowProductLevel",
  "state": "RAISED",  // or "CLEARED"
  "timestamp": "2025-11-28T03:15:50.675245Z"
}
```

- Broadcasts to all connected WebSocket clients
- WebSocket server runs on `ws://0.0.0.0:8765`

### 7. **Frontend Receives WebSocket Messages** (`frontend/components/AlarmEvents.tsx`)

**What happens:**
- Frontend connects to WebSocket: `ws://localhost:8765` (or your server)
- Receives alarm events in real-time
- Displays popup notifications for RAISED alarms
- Updates alarm list in real-time

---

## Complete Data Flow Diagram

```
Mock PLC Agent (Python)
    │
    │ Every 2 seconds
    │
    ├─► Generates random alarms (4-7% probability)
    │
    ├─► Publishes to MQTT: plc/machine-01/bottlefiller/alarms
    │   {
    │     "LowProductLevel": true/false,
    │     "Overfill": true/false,
    │     ...
    │   }
    │
    ▼
MQTT Broker
    │
    │ Forwards message
    │
    ▼
Alarm Monitor (Python)
    │
    ├─► Subscribes to: plc/+/bottlefiller/alarms
    │
    ├─► Receives alarm payload
    │
    ├─► Compares with previous state
    │
    ├─► Detects transition (false→true or true→false)
    │
    ├─► Creates event: {state: "RAISED" or "CLEARED", ...}
    │
    └─► Broadcasts via WebSocket: ws://0.0.0.0:8765
        │
        ▼
Frontend (Next.js)
    │
    ├─► Connects to WebSocket
    │
    ├─► Receives alarm events
    │
    ├─► Shows popup notification (for RAISED)
    │
    └─► Updates alarm list in real-time
```

---

## Key Points

### 1. **Random Generation**
- Alarms are generated randomly each cycle (every 2 seconds)
- Each alarm has a different probability (4-7%)
- States can change from cycle to cycle

### 2. **State Transitions Only**
- Alarm Monitor only triggers events on **state changes**
- If an alarm stays `true` for multiple cycles, only the first transition triggers an event
- This prevents spam - you only see alarms when they change state

### 3. **Alarm Mapping**
- MQTT uses simple names: `LowProductLevel`, `Overfill`, etc.
- UI uses formatted names: `AlarmLowProductLevel`, `AlarmOverfill`, etc.
- Mapping happens in `check_alarm_transitions()` function

### 4. **Machine Types**
- **Bottle Filler**: Tracks `LowProductLevel`, `Overfill`, `Underfill`, `CapMissing`
- **Lathe**: Tracks `spindle_overload`, `chuck_not_clamped`, `door_open`, `tool_wear`, `coolant_low`

### 5. **WebSocket Broadcasting**
- All connected frontend clients receive alarm events
- Events are broadcast in real-time
- No polling needed - true real-time updates

---

## Testing the Flow

### 1. Check Mock PLC Agent
```bash
# Check if agent is running
ps aux | grep mock_plc_agent

# Check agent logs
tail -f /tmp/mock_plc_agent.log
```

### 2. Check Alarm Monitor
```bash
# Check if alarm monitor is running
ps aux | grep alarm_monitor

# Check alarm events file
cat /tmp/alarm_events.json | tail -20
```

### 3. Check MQTT Messages
```bash
# Subscribe to MQTT topic (if you have mosquitto_sub)
mosquitto_sub -h localhost -p 8883 -t "plc/+/bottlefiller/alarms" -u your_username -P your_password
```

### 4. Check WebSocket
```bash
# Test WebSocket connection (if you have wscat)
wscat -c ws://localhost:8765
```

---

## Adjusting Alarm Frequency

To change how often alarms appear, modify `mock_plc_agent/mock_plc_agent.py`:

**Current settings (lines 106-110):**
```python
"LowProductLevel": random.random() > 0.94,  # 6% chance (0.94 = 6% above threshold)
"Overfill": random.random() > 0.96,         # 4% chance
"Underfill": random.random() > 0.95,        # 5% chance
"CapMissing": random.random() > 0.93,       # 7% chance
```

**To increase frequency:**
- Lower the threshold (e.g., `> 0.90` = 10% chance)
- Example: `random.random() > 0.85` = 15% chance

**To decrease frequency:**
- Raise the threshold (e.g., `> 0.97` = 3% chance)
- Example: `random.random() > 0.98` = 2% chance

**After changing, restart the agent:**
```bash
pkill -f mock_plc_agent.py
python3 mock_plc_agent/mock_plc_agent.py
```

---

## Summary

1. **Mock PLC Agent** generates alarms randomly (4-7% probability)
2. **Publishes to MQTT** every 2 seconds on `plc/{machine_id}/bottlefiller/alarms`
3. **Alarm Monitor** subscribes and detects state transitions
4. **Broadcasts via WebSocket** when alarms change state (RAISED or CLEARED)
5. **Frontend** receives WebSocket messages and displays real-time alerts

The key is that alarms are **randomly generated** each cycle, and the **Alarm Monitor only triggers events on state transitions**, not continuous states.

